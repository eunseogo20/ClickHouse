---
toc_priority : 0
toc_title : "개요"
---

# ClickHouse이란? {# what-is-clickhouse}

ClickHouse 쿼리의 온라인 분석 처리 (OLAP) 용 열 지향 데이터베이스 관리 시스템 (DBMS)입니다.

"일반"행 지향 DBMS에서는 데이터가 다음 순서로 저장됩니다:

| Row | WatchID     | JavaEnable | Title              | GoodEvent | EventTime           |
|-----|-------------|------------|--------------------|-----------|---------------------|
| #0 | 89354350662 | 1          | Investor Relations | 1         | 2016-05-18 05:19:20 |
| #1 | 90329509958 | 0          | Contact us         | 1         | 2016-05-18 08:10:20 |
| #2 | 89953706054 | 1          | Mission            | 1         | 2016-05-18 07:38:00 |
| #N | …           | …          | …                  | …         | …                   |

즉, 행과 관련된 모든 값은 물리적으로 인접에 저장됩니다.

행 지향 DBMS의 예 : MySQL, Postgres 및 MS SQL Server

열 지향 DBMS에서는 데이터는 다음과 같이 저장됩니다 :

| Row:        | #0                 | #1                 | #2                 | #N |
|-------------|---------------------|---------------------|---------------------|-----|
| WatchID:    | 89354350662         | 90329509958         | 89953706054         | …   |
| JavaEnable: | 1                   | 0                   | 1                   | …   |
| Title:      | Investor Relations  | Contact us          | Mission             | …   |
| GoodEvent:  | 1                   | 1                   | 1                   | …   |
| EventTime:  | 2016-05-18 05:19:20 | 2016-05-18 08:10:20 | 2016-05-18 07:38:00 | …   |

이러한 예는 데이터가 배치되는 순서만을 보여줍니다.
다른 열의 값은 별도로 저장되어 같은 열의 데이터가 함께 저장됩니다.

열 지향 DBMS 예 : Vertica, Paraccel (Actian Matrix and Amazon Redshift), Sybase IQ, Exasol, Infobright, InfiniDB, MonetDB (VectorWise and Actian Vector) LucidDB, SAP HANA, Google Dremel, Google PowerDrill, Druid 및 kdb +

다른 데이터 저장 순서는 다른 시나리오에 따라 적합합니다.
데이터 액세스 시나리오는 쿼리 종류, 빈도 비율을 말합니다. 쿼리에서 읽을의 각종 데이터의 양 (행, 열 바이트). 데이터를 읽고 업데이트의 관계. 작업 데이터의 크기와 로컬 사용 방법. 트랜잭션이 사용되는지 여부와 그들이 어느 정도 분리되어 있는가? 데이터 복제 및 논리적 무결성 요구 사항. 쿼리 유형에 따른 지연 및 처리량 요구 사항 등.

시스템의 부하가 높을수록 사용 시나리오의 요구 사항에 맞게 설치 된 시스템을 사용자 정의하는 것이 더 중요이 사용자는보다 효율적입니다. 크게 다른 시나리오에 동일 적합한 시스템은 없습니다. 시스템이 다양한 시나리오에 적응 가능한 경우 부하가이 시스템은 모든 시나리오를 동등하게 부족하게 처리하거나 하나 또는 몇 가지 가능한 시나리오에서 잘 작동합니다.

## OLAP 시나리오의 주요 속성 {# key-properties-of-olap-scenario}

- 요청의 대부분은 읽기 액세스 용이다.
- 데이터는 한 줄이 아니라 꽤 큰 배치 (\> 1000 행)으로 업데이트됩니다. 또는 전혀 업데이트되지 않는다.
- 데이터는 DB에 추가되지만, 변경되지 않는다.
- 읽기의 경우 매우 많은 행이 DB에서 추출되지만, 일부 열만.
- 테이블은 "폭이 넓어"많은 열이 포함된다.
- 쿼리은 비교적 드문 (일반적으로 서버 당 초당 수백 또는 그 이하의 수의 쿼리).
- 간단한 쿼리는 약 50 밀리 초 지연이 용인된다.
- 열의 값은 매우 작아 수치와 짧은 문자열 (예를 들어, URL 당 60 바이트).
- 단일 쿼리를 처리하는 경우, 높은 처리량이 필요 (서버 당 초당 최대 수십억 행).
- 트랜잭션은 필요 없다.
- 데이터의 일관성 요구 사항이 낮다.
- 쿼리 당 하나의 큰 테이블이있다. 하나를 제외한 모든 테이블은 작다.
- 쿼리 결과는 원본 데이터보다 훨씬 작아진다. 즉, 데이터는 필터링 또는 집계되기 때문에 결과는 단일 서버의 RAM에 맞습니다.

OLAP 시나리오는 다른 일반적인 시나리오 (OLTP 및 Key-Value 액세스 등)과는 매우 다른 것을 쉽게 알 수 있습니다. 따라서 괜찮은 성능을 얻으려면, OLTP 또는 Key-Value DB를 사용하여 분석 쿼리를 처리하려고하는 것은 무의미합니다. 예를 들어, 분석에 MongoDB 또는 Redis를 사용하려고하면 OLAP 데이터베이스에 비해 성능이 매우 부족합니다.

## OLAP 시나리오에서 열 지향 데이터베이스가 잘 작동하는 이유 {# why-column-oriented-databases-work-better-in-the-olap-scenario}

열 지향 데이터베이스는 OLAP 시나리오에 더 적합합니다. 대부분의 쿼리 처리가 적어도 100 배 빠릅니다. 이유를 다음에 자세히 설명되어 있지만, 그 근거는 시각적으로 쉽게 설명 할 수 있습니다 :

** 행 지향 DBMS **

![Row-oriented](images/row-oriented.gif#)

** 열 지향 DBMS **

![Column-oriented](images/column-oriented.gif#)

차이를 알았습니까?

### 입출력 {#inputoutput}
1. 분석 쿼리는 약간 테이블 열만을 읽어야합니다. 열 지향 데이터베이스에서 필요한 데이터 만 읽을 수 있습니다. 예를 들어, 100 중 5 개의 열이 필요한 경우 I / O가 20 배 감소되는 것을 기대할 수 있습니다.
2. 데이터는 패킷으로 읽기 때문에 압축이 용이합니다. 열 데이터도 압축 쉽습니다. 이로 인해 I / O 볼륨이 더욱 절감됩니다.
3. I / O 절감을 통해 더 많은 데이터가 시스템 캐시에 들어갑니다.

예를 들어, "각 광고 플랫폼의 레코드 수를 카운트하는"쿼리는 하나의 '광고 플랫폼 ID "열을 읽을 필요가 있습니다 만, 이것은 비 압축에서는 1 바이트의 공간을 필요로합니다. 트래픽의 대부분이 광고 플랫폼의 것이 아닌 경우,이 열은 적어도 10 배의 압축을 기대할 수 있습니다. 빠른 압축 알고리즘을 사용하면 초당 적어도 비 압축 데이터로 환산하여 몇 기가 바이트의 속도로 데이터를 배포 할 수 있습니다. 즉,이 쿼리는 단일 서버에서 초당 약 수십억 행의 속도로 처리 할 수 있습니다. 이 속도는 확실히 실제로 달성됩니다.

### CPU {#cpu}

쿼리를 실행하려면 많은 행을 처리해야하기 때문에 개별 행이 아닌 벡터 전체의 모든 조작을 발송하거나 발송 비용이 거의 없도록 쿼리 엔진을 구현하면 효율적입니다. 적절한 디스크 서브 시스템에서이를 수행하지 않으면 쿼리 인터프리터가 필연적으로 CPU를 실속시킵니다.
데이터를 열에 저장 가능한 경우 열마다 처리하는 것은 의미가 있습니다.

이렇게 두 가지 방법이 있습니다 :

1. 벡터 엔진. 모든 작업은 별도의 값이 아닌 벡터에 대해 설명합니다. 이것은 작업을 자주 호출 할 필요가없이 발송 비용이 무시할 수있는 것을 의미합니다. 작업 코드는 최적화 된 내부 사이클이 포함되어 있습니다.

2. 코드 생성. 쿼리에 대해 생성 된 코드는 모든 간접 호출이 포함되어 있습니다.

이것은 간단한 쿼리를 실행하는 경우에는 의미가 없기 때문에 "보통의"데이터베이스에서 실행되지 않습니다. 그러나 예외가 있습니다. 예를 들어, MemSQL은 코드 생성을 사용하여 SQL 쿼리를 처리 할 때의 지연을 줄일 수 있습니다. (비교를 위해 분석 DBMS에서는 대기 시간이 아니라 처리량의 최적화가 필요합니다.)

CPU 효율성을 위해 쿼리 언어는 선언적 (SQL 또는 MDX), 또는 적어도 벡터 (J, K)이어야합니다. 쿼리는 최적화를 가능하게하는 암묵적인 루프 만 포함해야합니다.

{## [원본 기사] (https://clickhouse.tech/docs/en/) ##}
